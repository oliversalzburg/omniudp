using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;
using System.Threading;
using NDesk.Options;
using PCSC;
using log4net;
using OmniUdp.Handler;

namespace OmniUdp {
  /// <summary>
  ///   Main application class
  /// </summary>
  internal static class Program {
    /// <summary>
    ///   Commandline options for this application
    /// </summary>
    private static class CommandLineOptions {
      #region Modes of Operation
      /// <summary>
      ///   Should newly read UIDs be broadcasted through the network?
      /// </summary>
      internal static bool UseBroadcast { get; set; }

      /// <summary>
      ///   The web API endpoint where to send registered events.
      /// </summary>
      internal static string RestEndpoint { get; set; }
      #endregion

      /// <summary>
      ///   The network <see langword="interface" /> from which to broadcast.
      /// </summary>
      internal static string NetworkInterface { get; set; }

      /// <summary>
      ///   The IP address from which to broadcast.
      /// </summary>
      internal static string IPAddress { get; set; }

      /// <summary>
      ///   Use only the loopback device for broadcasting.
      /// </summary>
      internal static bool UseLoopback { get; set; }

      /// <summary>
      ///   The identifier to send with each broadcasted UID.
      /// </summary>
      internal static string Identifier { get; set; }

      /// <summary>
      ///   Encode the UID as an ASCII string before broadcasting.
      /// </summary>
      internal static bool Ascii { get; set; }

      /// <summary>
      ///   Should the demo mode be enabled?
      ///   Demo mode allows simulating events generated by UID readers.
      /// </summary>
      internal static bool DemoMode { get; set; }

      /// <summary>
      ///   Should the command line help be displayed?
      /// </summary>
      internal static bool ShowHelp { get; set; }

      /// <summary>
      ///   Allowed https without certificate.
      /// </summary>
      internal static bool NoCertificate { get; set; }
    }

    /// <summary>
    ///   The logging interface.
    /// </summary>
    private static readonly ILog Log = LogManager.GetLogger( System.Reflection.MethodBase.GetCurrentMethod().DeclaringType );

    /// <summary>
    ///   <see cref="Program.Main" /> entry point
    /// </summary>
    private static void Main( string[] args ) {
      if( ParseCommandLine( args ) ) {
        return;
      }

      try {
        Console.WindowWidth = 160;
        Console.WindowHeight = 50;
      } catch( IOException ) {
        // Maybe there is no console window (stream redirection)
      } catch( NotSupportedException ) {
        // Can be thrown by Mono runtime
      }

      if( !String.IsNullOrEmpty( CommandLineOptions.Identifier ) ) {
        Log.InfoFormat( "Using identifier '{0}'.", CommandLineOptions.Identifier );
      }

      ConsecutiveStrategiesStrategy eventHandlingStrategy = new ConsecutiveStrategiesStrategy();

      // If no REST API endpoint was configured, use UDP broadcasting.
      if( string.IsNullOrEmpty( CommandLineOptions.RestEndpoint ) ) {
        CommandLineOptions.UseBroadcast = true;
      }
      // Construct the appropriate event handling strategy.
      if( CommandLineOptions.UseBroadcast ) {
        eventHandlingStrategy.Strategies.Add( 
          new UdpBroadcastStrategy( 
            CommandLineOptions.NetworkInterface, 
            CommandLineOptions.IPAddress, 
            CommandLineOptions.UseLoopback, 
            new Payload.ByteArrayFormatter( 
              CommandLineOptions.Identifier, 
              CommandLineOptions.Ascii ) ) );
      } 
      if( !String.IsNullOrEmpty( CommandLineOptions.RestEndpoint ) ) {
        eventHandlingStrategy.Strategies.Add( 
          new RestEndpointStrategy( 
            CommandLineOptions.RestEndpoint, 
            CommandLineOptions.NoCertificate,
            new Payload.JsonFormatter( 
              CommandLineOptions.Ascii, 
              CommandLineOptions.Identifier ) ) );
      }

      // Construct the core application and run it in a separate thread.
      Application app = CommandLineOptions.DemoMode
                          ? new DemoApplication( eventHandlingStrategy )
                          : new Application( eventHandlingStrategy );

      Thread applicationThread = new Thread( () => ApplicationHandler( app ) );
      applicationThread.Start();

      // Let the program run until the user presses a key
      Console.Title = "Press ESC to exit.";

      bool exitApplication = false;
      do {
        if( Console.KeyAvailable ) {
          ConsoleKeyInfo consoleKeyInfo = Console.ReadKey( true );
          ConsoleKey consoleKey = consoleKeyInfo.Key;
          if( ConsoleKey.Escape == consoleKey ) {
            exitApplication = true;
          }
          app.HandleKeyboardInput( consoleKeyInfo );

        } else {
          if( app.Destroyed ) {
            break;
          }
          Thread.Sleep( TimeSpan.FromSeconds( 1.0 ) );
        }
      } while( !exitApplication );

      // Signal the application thread to exit.
      if( null != app.ExitApplication ) {
        app.ExitApplication.Set();
      }
    }

    /// <summary>
    ///   Handles running the core application.
    /// </summary>
    /// <param name="app">The application to wrap.</param>
    private static void ApplicationHandler( Application app ) {
      try {
        app.Run();
      } catch( InvalidOperationException ex ) {
        Log.Error( ex );
        Console.ReadKey();
      } finally {
        app.Destroyed = true;
      }
    }

    /// <summary>
    ///   Parses command line parameters.
    /// </summary>
    /// <param name="args">
    ///   The command line parameters passed to the program.
    /// </param>
    /// <returns>
    ///   <see langword="true" /> if the application should exit.
    /// </returns>
    private static bool ParseCommandLine( IEnumerable<string> args ) {
      OptionSet options = new OptionSet {
        {"broadcast", "Use UDP broadcasting mode of operation.", v => CommandLineOptions.UseBroadcast = true},
        {"endpoint=", "Use REST mode of operation with given endpoint.", v => CommandLineOptions.RestEndpoint = v},
        {"interface=", "The network interface from which to broadcast. By default all interfaces are used.", v => CommandLineOptions.NetworkInterface = v},
        {"ip=", "The IP address from which to broadcast. By default all addresses are used.", v => CommandLineOptions.IPAddress = v},
        {"loopback", "Use only the loopback device. Overrides other options.", v => CommandLineOptions.UseLoopback = true},
        {"identifier=", "The identifier to broadcast with every UID.", v => CommandLineOptions.Identifier = v},
        {"ascii", "Encode the UID as an ASCII string before broadcasting.", v => CommandLineOptions.Ascii = true},
        {"demo", "Enable demo mode.", v => CommandLineOptions.DemoMode = true},
        {"nocertificate", "Allows to use https without certificate.", v => CommandLineOptions.NoCertificate = true},
        {"h|?|help", "Shows this help message", v => CommandLineOptions.ShowHelp = v != null}
      };

      try {
        options.Parse( args );
      } catch( OptionException ex ) {
        Console.Write( "{0}:", new FileInfo( Assembly.GetExecutingAssembly().Location ).Name );
        Console.WriteLine( ex.Message );
        Console.WriteLine(
          "Try '{0} --help' for more information.", new FileInfo( Assembly.GetExecutingAssembly().Location ).Name );
        return true;
      }

      if( CommandLineOptions.ShowHelp ) {
        Console.WriteLine( "Usage: {0} [OPTIONS]", new FileInfo( Assembly.GetExecutingAssembly().Location ).Name );
        Console.WriteLine();
        Console.WriteLine( "Options:" );
        Console.WriteLine();
        options.WriteOptionDescriptions( Console.Out );
        return true;
      }

      return false;
    }
  }
}